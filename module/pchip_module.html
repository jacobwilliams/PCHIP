<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   
   <meta name="description" content="PCHIP -- Piecewise Cubic Hermite Interpolation Package">
    
    <meta name="author" content="Jacob Williams" >
    <link rel="icon" href="../favicon.png">

    <title>pchip_module &ndash; PCHIP</title>

    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
    
    <link  href="../tipuesearch/tipuesearch.css" rel="stylesheet">
    
    

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script src="../js/jquery-2.1.3.min.js"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>

  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">PCHIP </a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
        
            <li class="dropdown hidden-xs visible-sm visible-md hidden-lg">
              <a href="#" class="dropdown-toggle"
              data-toggle="dropdown" role="button"
              aria-haspopup="true"
     aria-expanded="false">Contents <span class="caret"></span></a>
        <ul class="dropdown-menu">
          
              
            <li><a href="../sourcefile/pchip_module.f90.html">Source File</a></li>
        
        
        
            <li><a href="../lists/modules.html">Modules</a></li>
        
            
                                
            <li><a href="../lists/procedures.html">Procedures</a></li>
        
               
               
        
        
            </ul>
        
            </li>


<li class="visible-xs hidden-sm visible-lg"><a href="../sourcefile/pchip_module.f90.html">Source File</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/modules.html">Modules</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/procedures.html">Procedures</a></li>

                             



          </ul>
        
        <form action="../search.html" class="navbar-form navbar-right" role="search">
        <div class="form-group">
          <input type="text" class="form-control" placeholder="Search" name="q" id="tipue_search_input" autocomplete="off" required>
        </div>
<!--
        <button type="submit" class="btn btn-default">Submit</button>
-->
        </form>
        
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
    
  
  <div class="row">
    <h1>pchip_module 
    <small>Module</small>
    
    </h1>
    
<div class="row">
  <div class="col-lg-12">
<div class="well well-sm">
  <ul class="list-inline" style="margin-bottom:0px;display:inline">
     
     
     
     
     
    
    
     <li><i class="fa fa-list-ol"></i>
       <a data-toggle="tooltip"
    data-placement="bottom" data-html="true"
    title="100.0% of total for modules and submodules.">1275 statements</a>
     </li> 
     
     
     
    <li><i class="fa fa-code"></i><a href="../src/pchip_module.f90"> Source File</a></li>
     
     
  </ul>
  <ol class="breadcrumb in-well text-right">
  
    
     <li><a href='../sourcefile/pchip_module.f90.html'>pchip_module.f90</a></li>
    
  
     <li class="active">pchip_module</li>
  </ol>
</div>
</div>
</div>
<script>
  $(function () {
  $('[data-toggle="tooltip"]').tooltip()
  })
</script>

  </div>
  
  <div class="row">
    <div class="col-md-3 hidden-xs hidden-sm visible-md visible-lg">
    
<div id="sidebar">
  
<h3>Contents</h3>
 













<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#funcs-0">Functions</a></h3></div>
  <div id="funcs-0" class="panel-collapse collapse">
    <div class="list-group">
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchia">dpchia</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchid">dpchid</a>
      
    </div>
  </div>
</div>



<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#subs-0">Subroutines</a></h3></div>
  <div class="list-group">
    <div id="subs-0" class="panel-collapse collapse">
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dchfdv">dchfdv</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dchfev">dchfev</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchbs">dpchbs</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchcm">dpchcm</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchfd">dpchfd</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchfe">dpchfe</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchic">dpchic</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchim">dpchim</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchsp">dpchsp</a>
      
    </div>
  </div>
</div>










</div>

    </div>
    
    <div class="col-md-9" id='text'>
    <p>A Fortran package for piecewise cubic Hermite interpolation of data.</p>
<h3>Author</h3>
<ul>
<li>Fritsch, F. N., (LLNL) -- original author</li>
<li>Oct 2019 : Jacob Williams, Extensive refactoring
    and modernization of the SLATEC code.</li>
</ul>
      <br>
    
  
    <div class="panel panel-default">
      <div class="panel-heading">
  <h3 class="panel-title">Uses</h3>
      </div>
      <ul class="list-group">
      
      <li class="list-group-item">
  <ul class="list-inline">
    
    <li><a href="http://fortranwiki.org/fortran/show/iso_fortran_env">iso_fortran_env</a></li>
    
  </ul>
      </li>
      
      
      
      </ul>
    </div>
    

    
    

    <br>

    <section class="visible-xs visible-sm hidden-md">
      
<h3>Contents</h3>
 













<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#funcs-1">Functions</a></h3></div>
  <div id="funcs-1" class="panel-collapse collapse">
    <div class="list-group">
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchia">dpchia</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchid">dpchid</a>
      
    </div>
  </div>
</div>



<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title"><a data-toggle="collapse" href="#subs-1">Subroutines</a></h3></div>
  <div class="list-group">
    <div id="subs-1" class="panel-collapse collapse">
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dchfdv">dchfdv</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dchfev">dchfev</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchbs">dpchbs</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchcm">dpchcm</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchfd">dpchfd</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchfe">dpchfe</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchic">dpchic</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchim">dpchim</a>
      
      <a class="list-group-item" href="../module/pchip_module.html#proc-dpchsp">dpchsp</a>
      
    </div>
  </div>
</div>










    </section>
    <br class="visible-xs visible-sm hidden-md">

    

    
    
    
    
    

    
    
    
    
     
    <section>
    <h2>Functions</h2>
    
    
  <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-dpchia"></span><h3>
public function <a href='../proc/dpchia.html'>dpchia</a>(n, x, f, d, incfd, skip, a, b, ierr) result(value)
    
    
   
</h3></div>
  <div class="panel-body">
       
    







<p>Piecewise Cubic Hermite Integrator, Arbitrary limits</p><a href="../proc/dpchia.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
    <h4>Arguments</h4>
    
      
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>number of data points.  (Error return if N&lt;2).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x</strong>(*)</td><td><p>array of independent variable values.  The
 elements of X must be strictly increasing:
 <code>X(I-1) &lt; X(I),  I = 2(1)N</code>.
 (Error return if not.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f</strong>(incfd,*)</td><td><p>array of function values.  F(1+(I-1)*INCFD) is
 the value corresponding to X(I).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d</strong>(incfd,*)</td><td><p>array of derivative values.  D(1+(I-1)*INCFD)
 is the value corresponding to X(I).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>incfd</strong></td><td><p>increment between successive values in F and D.
 (Error return if  INCFD&lt;1).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>logical,</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>skip</strong></td><td><p>logical variable which should be set to
 .TRUE. if the user wishes to skip checks for validity of
 preceding parameters, or to .FALSE. otherwise.
 This will save time in case these checks have already
 been performed (say, in <a href="../proc/dpchim.html">dpchim</a> or <a href="../proc/dpchic.html">dpchic</a>).
 SKIP will be set to .TRUE. on return with IERR&gt;=0 .</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>a</strong></td><td><p>the limits of integration.
 NOTE:  There is no requirement that [A,B] be contained in
        [X(1),X(N)].  However, the resulting integral value
        will be highly suspect, if not.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>b</strong></td><td><p>the limits of integration.
 NOTE:  There is no requirement that [A,B] be contained in
        [X(1),X(N)].  However, the resulting integral value
        will be highly suspect, if not.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ierr</strong></td><td><p>error flag.</p>
<ul>
<li>Normal return:<ul>
<li>IERR = 0  (no errors).</li>
</ul>
</li>
<li>Warning errors:<ul>
<li>IERR = 1  if  A  is outside the interval [X(1),X(N)].</li>
<li>IERR = 2  if  B  is outside the interval [X(1),X(N)].</li>
<li>IERR = 3  if both of the above are true.  (Note that this
           means that either [A,B] contains data interval
           or the intervals do not intersect at all.)</li>
</ul>
</li>
<li>"Recoverable" errors:<ul>
<li>IERR = -1  if N&lt;2 .</li>
<li>IERR = -2  if INCFD&lt;1 .</li>
<li>IERR = -3  if the X-array is not strictly increasing.
   (VALUE will be zero in any of these cases.)
  NOTE:  The above errors are checked in the order listed,
      and following arguments have <strong>NOT</strong> been validated.</li>
<li>IERR = -4  in case of an error return from DPCHID (which
            should never occur).</li>
</ul>
</li>
</ul></td>
  
</tr>

</tbody>
</table>

      
    
    

  
  
  
  
     <h4>Return Value <small>real(kind=wp)
  </small></h4>
  <p>value of the requested integral.</p>
    

  </div>
  </div>

    
    
  <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-dpchid"></span><h3>
public function <a href='../proc/dpchid.html'>dpchid</a>(n, x, f, d, incfd, skip, ia, ib, ierr) result(value)
    
    
   
</h3></div>
  <div class="panel-body">
       
    







<p>Piecewise Cubic Hermite Integrator, Data limits</p><a href="../proc/dpchid.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
    <h4>Arguments</h4>
    
      
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>number of data points.  (Error return if N&lt;2).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x</strong>(*)</td><td><p>array of independent variable values.  The
 elements of X must be strictly increasing:
 <code>X(I-1) &lt; X(I),  I = 2(1)N</code>.
 (Error return if not.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f</strong>(incfd,*)</td><td><p>array of function values.  <code>F(1+(I-1)*INCFD)</code> is
 the value corresponding to <code>X(I)</code>.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d</strong>(incfd,*)</td><td><p>array of derivative values. <code>D(1+(I-1)*INCFD)</code>
 is the value corresponding to <code>X(I)</code>.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>incfd</strong></td><td><p>increment between successive values in F and D.
 (Error return if  INCFD&lt;1).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>logical,</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>skip</strong></td><td><p>logical variable which should be set to
 .TRUE. if the user wishes to skip checks for validity of
 preceding parameters, or to .FALSE. otherwise.
 This will save time in case these checks have already
 been performed (say, in <a href="../proc/dpchim.html">dpchim</a> or <a href="../proc/dpchic.html">dpchic</a>).
 SKIP will be set to .TRUE. on return with IERR = 0 or -4.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ia</strong></td><td><p>indices in X-array for the limits of integration.
 both must be in the range [1,N].  (Error return if not.)
 No restrictions on their relative values.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ib</strong></td><td><p>indices in X-array for the limits of integration.
 both must be in the range [1,N].  (Error return if not.)
 No restrictions on their relative values.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ierr</strong></td><td><p>error flag.</p>
<ul>
<li>
<p>Normal return:</p>
<ul>
<li>IERR = 0  (no errors).</li>
</ul>
</li>
<li>
<p>"Recoverable" errors (VALUE will be zero in any of these cases.):</p>
<ul>
<li>IERR = -1  if N&lt;2 .</li>
<li>IERR = -2  if INCFD&lt;1 .</li>
<li>IERR = -3  if the X-array is not strictly increasing.</li>
<li>IERR = -4  if IA or IB is out of range.</li>
</ul>
</li>
</ul>
<p>NOTE: The above errors are checked in the order listed,
 and following arguments have <strong>NOT</strong> been validated.</p></td>
  
</tr>

</tbody>
</table>

      
    
    

  
  
  
  
     <h4>Return Value <small>real(kind=wp)
  </small></h4>
  <p>value of the requested integral.</p>
    

  </div>
  </div>

    
    </section>
    <br>
    

    
    <section>
    <h2>Subroutines</h2>
    
    
  <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-dchfdv"></span><h3>
public subroutine <a href='../proc/dchfdv.html'>dchfdv</a>(x1, x2, f1, f2, d1, d2, ne, xe, fe, de, next, ierr)
    
    
   
</h3></div>
  <div class="panel-body">
       
    







<p>Cubic Hermite Function and Derivative Evaluator</p><a href="../proc/dchfdv.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
    <h4>Arguments</h4>
    
      
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x1</strong></td><td><p>initial endpoint of interval of definition of cubic. (Error return if X1==X2.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x2</strong></td><td><p>final endpoint of interval of definition of cubic. (Error return if X1==X2.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f1</strong></td><td><p>value of function at X1.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f2</strong></td><td><p>value of function at X2.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d1</strong></td><td><p>value of derivative at X1.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d2</strong></td><td><p>value of derivative at X2.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ne</strong></td><td><p>number of evaluation points.  (Error return if NE&lt;1).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in),</td>
  <td></td>
  
  <td>dimension(*)</td><td>::</td>
  <td><strong>xe</strong></td><td><p>array of points at which the functions are to
 be evaluated.  If any of the XE are outside the interval
 [X1,X2], a warning error is returned in NEXT.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(out),</td>
  <td></td>
  
  <td>dimension(*)</td><td>::</td>
  <td><strong>fe</strong></td><td><p>array of values of the cubic function
 defined by X1,X2, F1,F2, D1,D2 at the points XE.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(out),</td>
  <td></td>
  
  <td>dimension(*)</td><td>::</td>
  <td><strong>de</strong></td><td><p>array of values of the first derivative of
 the same function at the points XE.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out),</td>
  <td></td>
  
  <td>dimension(2)</td><td>::</td>
  <td><strong>next</strong></td><td><p>array indicating number of extrapolation points:</p>
<ul>
<li>NEXT(1) = number of evaluation points to left of interval.</li>
<li>NEXT(2) = number of evaluation points to right of interval.</li>
</ul></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ierr</strong></td><td><p>error flag.</p>
<p>Normal return:</p>
<ul>
<li>IERR = 0  (no errors).</li>
</ul>
<p>"Recoverable" errors (output arrays have not been changed):</p>
<ul>
<li>IERR = -1  if NE&lt;1 .</li>
<li>IERR = -2  if X1==X2 .</li>
</ul></td>
  
</tr>

</tbody>
</table>

      
    
    

  </div>
  </div>

    
    
  <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-dchfev"></span><h3>
public subroutine <a href='../proc/dchfev.html'>dchfev</a>(x1, x2, f1, f2, d1, d2, ne, xe, fe, next, ierr)
    
    
   
</h3></div>
  <div class="panel-body">
       
    







<p>Cubic Hermite Function Evaluator</p><a href="../proc/dchfev.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
    <h4>Arguments</h4>
    
      
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x1</strong></td><td><p>initial endpoint of interval of definition of cubic. (Error return if X1==X2.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x2</strong></td><td><p>final endpoint of interval of definition of cubic. (Error return if X1==X2.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f1</strong></td><td><p>value of function at X1.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f2</strong></td><td><p>value of function at X2.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d1</strong></td><td><p>value of derivative at X1.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d2</strong></td><td><p>value of derivative at X2.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ne</strong></td><td><p>number of evaluation points.  (Error return if NE&lt;1).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in),</td>
  <td></td>
  
  <td>dimension(*)</td><td>::</td>
  <td><strong>xe</strong></td><td><p>array of points at which the function is to
 be evaluated. If any of the XE are outside the interval
 [X1,X2], a warning error is returned in NEXT.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(out),</td>
  <td></td>
  
  <td>dimension(*)</td><td>::</td>
  <td><strong>fe</strong></td><td><p>array of values of the cubic function
 defined by X1,X2, F1,F2, D1,D2 at the points XE.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out),</td>
  <td></td>
  
  <td>dimension(2)</td><td>::</td>
  <td><strong>next</strong></td><td><p>integer array indicating number of extrapolation points:</p>
<ul>
<li>NEXT(1) = number of evaluation points to left of interval.</li>
<li>NEXT(2) = number of evaluation points to right of interval.</li>
</ul></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ierr</strong></td><td><p>error flag.</p>
<ul>
<li>Normal return:<ul>
<li>IERR = 0  (no errors).</li>
</ul>
</li>
<li>"Recoverable" errors (output arrays have not been changed):<ul>
<li>IERR = -1  if NE&lt;1 .</li>
<li>IERR = -2  if X1==X2 .</li>
</ul>
</li>
</ul></td>
  
</tr>

</tbody>
</table>

      
    
    

  </div>
  </div>

    
    
  <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-dpchbs"></span><h3>
public subroutine <a href='../proc/dpchbs.html'>dpchbs</a>(n, x, f, d, incfd, knotyp, nknots, t, bcoef, ndim, kord, ierr)
    
    
   
</h3></div>
  <div class="panel-body">
       
    







<p>Piecewise Cubic Hermite to B-Spline converter.</p><a href="../proc/dpchbs.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
    <h4>Arguments</h4>
    
      
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>the number of data points, N&gt;=2 .  (not checked)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x</strong>(*)</td><td><p>array of independent variable values.  The
 elements of X must be strictly increasing:
      X(I-1) &lt; X(I),  I = 2(1)N.   (not checked)
 nmax, the dimension of X, must be &gt;=N.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f</strong>(incfd,*)</td><td><p>array of dependent variable values.
 F(1+(I-1)*INCFD) is the value corresponding to X(I).
 nmax, the second dimension of F, must be &gt;=N.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d</strong>(incfd,*)</td><td><p>array of derivative values at the data points.
 D(1+(I-1)*INCFD) is the value corresponding to X(I).
 nmax, the second dimension of D, must be &gt;=N.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>incfd</strong></td><td><p>the increment between successive values in F and D.
 This argument is provided primarily for 2-D applications.
 It may have the value 1 for one-dimensional applications,
 in which case F and D may be singly-subscripted arrays.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>knotyp</strong></td><td><p>a flag to control the knot sequence.
 The knot sequence T is normally computed from X by putting
 a double knot at each X and setting the end knot pairs
 according to the value of KNOTYP:</p>
<ul>
<li>KNOTYP = 0:  Quadruple knots at X(1) and X(N).  (default)</li>
<li>KNOTYP = 1:  Replicate lengths of extreme subintervals:
                 T( 1 ) = T( 2 ) = X(1) - (X(2)-X(1))  ;
                 T(M+4) = T(M+3) = X(N) + (X(N)-X(N-1)).</li>
<li>KNOTYP = 2:  Periodic placement of boundary knots:
                 T( 1 ) = T( 2 ) = X(1) - (X(N)-X(N-1));
                 T(M+4) = T(M+3) = X(N) + (X(2)-X(1))  .
 Here M=NDIM=2*N.</li>
</ul>
<p>If the input value of KNOTYP is negative, however, it is
 assumed that NKNOTS and T were set in a previous call.
 This option is provided for improved efficiency when used
 in a parametric setting.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>nknots</strong></td><td><p>the number of knots.</p>
<ul>
<li>If KNOTYP&gt;=0, then NKNOTS will be set to NDIM+4.</li>
<li>If KNOTYP&lt;0, then NKNOTS is an input variable, and an
    error return will be taken if it is not equal to NDIM+4.</li>
</ul></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>t</strong>(*)</td><td><p>array of 2*N+4 knots for the B-representation.</p>
<ul>
<li>If KNOTYP&gt;=0, T will be returned by DPCHBS with the
   interior double knots equal to the X-values and the
   boundary knots set as indicated above.</li>
<li>If KNOTYP&lt;0, it is assumed that T was set by a
   previous call to DPCHBS.  (This routine does <strong>not</strong>
   verify that T forms a legitimate knot sequence.)</li>
</ul></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>bcoef</strong>(*)</td><td><p>array of 2*N B-spline coefficients.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ndim</strong></td><td><p>the dimension of the B-spline space.  (Set to 2*N.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>kord</strong></td><td><p>the order of the B-spline.  (Set to 4.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ierr</strong></td><td><p>an error flag:</p>
<ul>
<li>Normal return:<ul>
<li>IERR = 0  (no errors).</li>
</ul>
</li>
<li>"Recoverable" errors:<ul>
<li>IERR = -4  if KNOTYP&gt;2 .</li>
<li>IERR = -5  if KNOTYP&lt;0 and NKNOTS/=(2*N+4).</li>
</ul>
</li>
</ul></td>
  
</tr>

</tbody>
</table>

      
    
    

  </div>
  </div>

    
    
  <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-dpchcm"></span><h3>
public subroutine <a href='../proc/dpchcm.html'>dpchcm</a>(n, x, f, d, incfd, skip, ismon, ierr)
    
    
   
</h3></div>
  <div class="panel-body">
       
    







<p>Check a cubic Hermite function for monotonicity</p><a href="../proc/dpchcm.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
    <h4>Arguments</h4>
    
      
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>the number of data points.  (Error return if N&lt;2).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x</strong>(n)</td><td><p>array of independent variable values.  The
 elements of X must be strictly increasing:
      X(I-1) &lt; X(I),  I = 2(1)N.
 (Error return if not.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f</strong>(incfd,n)</td><td><p>array of function values.  F(1+(I-1)*INCFD) is
 the value corresponding to X(I).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d</strong>(incfd,n)</td><td><p>array of derivative values.  D(1+(I-1)*INCFD) is
 is the value corresponding to X(I).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>incfd</strong></td><td><p>the increment between successive values in F and D.
 (Error return if  INCFD&lt;1).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>logical,</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>skip</strong></td><td><p>logical variable which should be set to
 .TRUE. if the user wishes to skip checks for validity of
 preceding parameters, or to .FALSE. otherwise.
 This will save time in case these checks have already
 been performed.
 SKIP will be set to .TRUE. on normal return.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ismon</strong>(n)</td><td><p>array indicating on which intervals the
 PCH function defined by  N, X, F, D  is monotonic.
 For data interval [X(I),X(I+1)]:</p>
<ul>
<li>ISMON(I) = -3  if function is probably decreasing;</li>
<li>ISMON(I) = -1  if function is strictly decreasing;</li>
<li>ISMON(I) =  0  if function is constant;</li>
<li>ISMON(I) =  1  if function is strictly increasing;</li>
<li>ISMON(I) =  2  if function is non-monotonic;</li>
<li>ISMON(I) =  3  if function is probably increasing.</li>
</ul>
<p>If ABS(ISMON)=3, this means that the D-values are near
 the boundary of the monotonicity region.  A small
 increase produces non-monotonicity; decrease, strict
 monotonicity.</p>
<p>The above applies to I=1(1)N-1.  ISMON(N) indicates whether
 the entire function is monotonic on [X(1),X(N)].</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ierr</strong></td><td><p>error flag.</p>
<ul>
<li>Normal return:<ul>
<li>IERR = 0  (no errors).</li>
</ul>
</li>
<li>"Recoverable" errors:<ul>
<li>IERR = -1  if N&lt;2 .</li>
<li>IERR = -2  if INCFD&lt;1 .</li>
<li>IERR = -3  if the X-array is not strictly increasing.</li>
</ul>
</li>
</ul>
<p>(The ISMON-array has not been changed in any of these cases.)
 NOTE:  The above errors are checked in the order listed,
 and following arguments have <strong>NOT</strong> been validated.</p></td>
  
</tr>

</tbody>
</table>

      
    
    

  </div>
  </div>

    
    
  <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-dpchfd"></span><h3>
public subroutine <a href='../proc/dpchfd.html'>dpchfd</a>(n, x, f, d, incfd, skip, ne, xe, fe, de, ierr)
    
    
   
</h3></div>
  <div class="panel-body">
       
    







<p>Piecewise Cubic Hermite Function and Derivative evaluator</p><a href="../proc/dpchfd.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
    <h4>Arguments</h4>
    
      
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>number of data points.  (Error return if N&lt;2).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x</strong>(*)</td><td><p>array of independent variable values.  The
 elements of X must be strictly increasing:
 <code>X(I-1) &lt; X(I),  I = 2(1)N</code>.
 (Error return if not.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f</strong>(incfd,*)</td><td><p>array of function values.  F(1+(I-1)*INCFD) is
 the value corresponding to X(I).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d</strong>(incfd,*)</td><td><p>array of derivative values.  D(1+(I-1)*INCFD)
 is the value corresponding to X(I).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>incfd</strong></td><td><p>increment between successive values in F and D.
 (Error return if INCFD&lt;1).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>logical,</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>skip</strong></td><td><p>logical variable which should be set to
 .TRUE. if the user wishes to skip checks for validity of
 preceding parameters, or to .FALSE. otherwise.
 This will save time in case these checks have already
 been performed (say, in <a href="../proc/dpchim.html">dpchim</a> or <a href="../proc/dpchic.html">dpchic</a>).
 SKIP will be set to .TRUE. on normal return.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ne</strong></td><td><p>number of evaluation points.  (Error return if NE&lt;1).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>xe</strong>(*)</td><td><p>array of points at which the functions are to
 be evaluated.
 NOTES:</p>
<ol>
<li>The evaluation will be most efficient if the elements
    of XE are increasing relative to X;
    that is,   XE(J) &gt;= X(I)
    implies    XE(K) &gt;= X(I),  all K&gt;=J .</li>
<li>If any of the XE are outside the interval [X(1),X(N)],
    values are extrapolated from the nearest extreme cubic,
    and a warning error is returned.</li>
</ol></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>fe</strong>(*)</td><td><p>array of values of the cubic Hermite
 function defined by  N, X, F, D at the points XE.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>de</strong>(*)</td><td><p>array of values of the first derivative of
 the same function at the points XE.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ierr</strong></td><td><p>error flag.</p>
<ul>
<li>Normal return:<ul>
<li>IERR = 0  (no errors).</li>
</ul>
</li>
<li>Warning error:<ul>
<li>IERR&gt;0  means that extrapolation was performed at
  IERR points.</li>
</ul>
</li>
<li>"Recoverable" errors:<ul>
<li>IERR = -1  if N&lt;2 .</li>
<li>IERR = -2  if INCFD&lt;1 .</li>
<li>IERR = -3  if the X-array is not strictly increasing.</li>
<li>IERR = -4  if NE&lt;1 .</li>
</ul>
</li>
</ul>
<p>(Output arrays have not been changed in any of these cases.)</p>
<p>NOTE:  The above errors are checked in the order listed,
        and following arguments have <strong>NOT</strong> been validated.</p>
<ul>
<li>IERR = -5  if an error has occurred in the lower-level
              routine DCHFDV.  NB: this should never happen.
              Notify the author <strong>IMMEDIATELY</strong> if it does.</li>
</ul></td>
  
</tr>

</tbody>
</table>

      
    
    

  </div>
  </div>

    
    
  <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-dpchfe"></span><h3>
public subroutine <a href='../proc/dpchfe.html'>dpchfe</a>(n, x, f, d, incfd, skip, ne, xe, fe, ierr)
    
    
   
</h3></div>
  <div class="panel-body">
       
    







<p>Piecewise Cubic Hermite Function Evaluator</p><a href="../proc/dpchfe.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
    <h4>Arguments</h4>
    
      
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>number of data points.  (Error return if N&lt;2).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x</strong>(*)</td><td><p>array of independent variable values.  The
 elements of X must be strictly increasing:
 X(I-1) &lt; X(I),  I = 2(1)N.
 (Error return if not.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f</strong>(incfd,*)</td><td><p>array of function values.  F(1+(I-1)*INCFD) is
 the value corresponding to X(I).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d</strong>(incfd,*)</td><td><p>array of derivative values.  D(1+(I-1)*INCFD)
 is the value corresponding to X(I).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>incfd</strong></td><td><p>increment between successive values in F and D.
 (Error return if  INCFD&lt;1).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>logical,</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>skip</strong></td><td><p>logical variable which should be set to
 .TRUE. if the user wishes to skip checks for validity of
 preceding parameters, or to .FALSE. otherwise.
 This will save time in case these checks have already
 been performed (say, in <a href="../proc/dpchim.html">dpchim</a> or <a href="../proc/dpchic.html">dpchic</a>).
 SKIP will be set to .TRUE. on normal return.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ne</strong></td><td><p>number of evaluation points.  (Error return if NE&lt;1).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>xe</strong>(*)</td><td><p>array of points at which the function is to
 be evaluated.</p>
<p>NOTES:</p>
<ol>
<li>The evaluation will be most efficient if the elements
     of XE are increasing relative to X;
     that is,   <code>XE(J) &gt;= X(I)</code>
     implies    <code>XE(K) &gt;= X(I)</code>,  all <code>K&gt;=J</code>.</li>
<li>If any of the XE are outside the interval <code>[X(1),X(N)]</code>,
     values are extrapolated from the nearest extreme cubic,
     and a warning error is returned.</li>
</ol></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>fe</strong>(*)</td><td><p>array of values of the cubic Hermite
 function defined by  N, X, F, D  at the points XE.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ierr</strong></td><td><p>error flag.</p>
<ul>
<li>Normal return:<ul>
<li>IERR = 0  (no errors).</li>
</ul>
</li>
<li>Warning error:<ul>
<li>IERR&gt;0  means that extrapolation was performed at IERR points.</li>
</ul>
</li>
<li>"Recoverable" errors:<ul>
<li>IERR = -1  if N&lt;2 .</li>
<li>IERR = -2  if INCFD&lt;1 .</li>
<li>IERR = -3  if the X-array is not strictly increasing.</li>
<li>IERR = -4  if NE&lt;1 .</li>
</ul>
</li>
</ul>
<p>(The FE-array has not been changed in any of these cases.)
 NOTE: The above errors are checked in the order listed,
 and following arguments have <strong>NOT</strong> been validated.</p></td>
  
</tr>

</tbody>
</table>

      
    
    

  </div>
  </div>

    
    
  <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-dpchic"></span><h3>
public subroutine <a href='../proc/dpchic.html'>dpchic</a>(ic, vc, switch, n, x, f, d, incfd, wk, nwk, ierr)
    
    
   
</h3></div>
  <div class="panel-body">
       
    







<p>Piecewise Cubic Hermite Interpolation Coefficients.</p><a href="../proc/dpchic.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
    <h4>Arguments</h4>
    
      
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ic</strong>(2)</td><td><p>array of length 2 specifying desired boundary conditions:</p>
<ul>
<li>IC(1) = IBEG, desired condition at beginning of data.</li>
<li>IC(2) = IEND, desired condition at end of data.</li>
</ul>
<p>Valid values for IBEG:</p>
<ul>
<li>IBEG = 0  for the default boundary condition (the same as used by <a href="../proc/dpchim.html">dpchim</a>).</li>
<li>
<p>If IBEG/=0, then its sign indicates whether the boundary
            derivative is to be adjusted, if necessary, to be
            compatible with monotonicity:</p>
<ul>
<li>IBEG&gt;0  if no adjustment is to be performed.</li>
<li>IBEG&lt;0  if the derivative is to be adjusted for monotonicity.</li>
</ul>
</li>
</ul>
<p>Allowable values for the magnitude of IBEG are:</p>
<ul>
<li>IBEG = 1  if first derivative at X(1) is given in VC(1).</li>
<li>IBEG = 2  if second derivative at X(1) is given in VC(1).</li>
<li>IBEG = 3  to use the 3-point difference formula for D(1).
              (Reverts to the default b.c. if N&lt;3).</li>
<li>IBEG = 4  to use the 4-point difference formula for D(1).
              (Reverts to the default b.c. if N&lt;4).</li>
<li>IBEG = 5  to set D(1) so that the second derivative is continuous
              at X(2). (Reverts to the default b.c. if N&lt;4.)
              This option is somewhat analogous to the "not a knot"
              boundary condition provided by DPCHSP.</li>
</ul>
<p>NOTES (IBEG):</p>
<ol>
<li>An error return is taken if ABS(IBEG)&gt;5 .</li>
<li>Only in case  IBEG&lt;=0  is it guaranteed that the
     interpolant will be monotonic in the first interval.
     If the returned value of D(1) lies between zero and
     3<em>SLOPE(1), the interpolant will be monotonic.  This
     is </em><em>NOT</em>* checked if IBEG&gt;0 .</li>
<li>If IBEG&lt;0 and D(1) had to be changed to achieve mono-
     tonicity, a warning error is returned.</li>
</ol>
<p>IEND may take on the same values as IBEG, but applied to
 derivative at X(N).  In case IEND = 1 or 2, the value is
 given in VC(2).</p>
<p>NOTES (IEND):</p>
<ol>
<li>An error return is taken if ABS(IEND)&gt;5 .</li>
<li>Only in case  IEND&lt;=0  is it guaranteed that the
     interpolant will be monotonic in the last interval.
     If the returned value of D(1+(N-1)<em>INCFD) lies between
     zero and 3</em>SLOPE(N-1), the interpolant will be monotonic.
     This is <strong>NOT</strong> checked if IEND&gt;0 .</li>
<li>If IEND&lt;0 and D(1+(N-1)*INCFD) had to be changed to
     achieve monotonicity, a warning error is returned.</li>
</ol></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>vc</strong>(2)</td><td><p>array of length 2 specifying desired boundary
 values, as indicated above.</p>
<ul>
<li>VC(1) need be set only if IC(1) = 1 or 2 .</li>
<li>VC(2) need be set only if IC(2) = 1 or 2 .</li>
</ul></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>switch</strong></td><td><p>indicates desired treatment of points where
 direction of monotonicity switches:
 Set SWITCH to zero if interpolant is required to be mono-
 tonic in each interval, regardless of monotonicity of data.</p>
<p>NOTES:</p>
<ol>
<li>This will cause D to be set to zero at all switch
    points, thus forcing extrema there.</li>
<li>The result of using this option with the default boun-
    dary conditions will be identical to using DPCHIM, but
    will generally cost more compute time.
    This option is provided only to facilitate comparison
    of different switch and/or boundary conditions.</li>
</ol>
<p>Set SWITCH nonzero to use a formula based on the 3-point
 difference formula in the vicinity of switch points.</p>
<p>If SWITCH is positive, the interpolant on each interval
 containing an extremum is controlled to not deviate from
 the data by more than SWITCH*DFLOC, where DFLOC is the
 maximum of the change of F on this interval and its two
 immediate neighbors.</p>
<p>If SWITCH is negative, no such control is to be imposed.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>number of data points.  (Error return if N&lt;2).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x</strong>(*)</td><td><p>array of independent variable values.  The
 elements of X must be strictly increasing:
      X(I-1) &lt; X(I),  I = 2(1)N.
 (Error return if not.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f</strong>(incfd,*)</td><td><p>array of dependent variable values to be
 interpolated.  F(1+(I-1)*INCFD) is value corresponding to
 X(I).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d</strong>(incfd,*)</td><td><p>array of derivative values at the data
 points.  These values will determine a monotone cubic
 Hermite function on each subinterval on which the data
 are monotonic, except possibly adjacent to switches in
 monotonicity. The value corresponding to X(I) is stored in
      D(1+(I-1)*INCFD),  I=1(1)N.
 No other entries in D are changed.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>incfd</strong></td><td><p>increment between successive values in F and D.
 This argument is provided primarily for 2-D applications.
 (Error return if  INCFD&lt;1).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>wk</strong>(nwk)</td><td><p>array of working storage.  The user may
 wish to know that the returned values are:</p>
<ul>
<li><code>WK(I)     = H(I)     = X(I+1) - X(I)</code> ;</li>
<li><code>WK(N-1+I) = SLOPE(I) = (F(1,I+1) - F(1,I)) / H(I)</code></li>
</ul>
<p>for <code>I = 1(1)N-1</code>.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>nwk</strong></td><td><p>length of work array. (Error return if  NWK&lt;2*(N-1)).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ierr</strong></td><td><p>error flag.</p>
<ul>
<li>
<p>Normal return:</p>
<ul>
<li>IERR = 0  (no errors).</li>
</ul>
</li>
<li>
<p>Warning errors:</p>
<ul>
<li>IERR = 1  if IBEG&lt;0 and D(1) had to be adjusted for
            monotonicity.</li>
<li>IERR = 2  if IEND&lt;0 and D(1+(N-1)*INCFD) had to be
            adjusted for monotonicity.</li>
<li>IERR = 3  if both of the above are true.</li>
</ul>
</li>
<li>
<p>"Recoverable" errors:</p>
<ul>
<li>IERR = -1  if N&lt;2 .</li>
<li>IERR = -2  if INCFD&lt;1 .</li>
<li>IERR = -3  if the X-array is not strictly increasing.</li>
<li>IERR = -4  if ABS(IBEG)&gt;5 .</li>
<li>IERR = -5  if ABS(IEND)&gt;5 .</li>
<li>IERR = -6  if both of the above are true.</li>
<li>IERR = -7  if NWK&lt;2*(N-1) .</li>
</ul>
</li>
</ul>
<p>(The D-array has not been changed in any of these cases.)
 NOTE:  The above errors are checked in the order listed,
 and following arguments have <strong>NOT</strong> been validated.</p></td>
  
</tr>

</tbody>
</table>

      
    
    

  </div>
  </div>

    
    
  <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-dpchim"></span><h3>
public subroutine <a href='../proc/dpchim.html'>dpchim</a>(n, x, f, d, incfd, ierr)
    
    
   
</h3></div>
  <div class="panel-body">
       
    







<p>Piecewise Cubic Hermite Interpolation to Monotone data.</p><a href="../proc/dpchim.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
    <h4>Arguments</h4>
    
      
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>number of data points.  (Error return if N&lt;2).
 If N=2, simply does linear interpolation.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x</strong>(*)</td><td><p>array of independent variable values.  The
 elements of X must be strictly increasing:
 <code>X(I-1) &lt; X(I),  I = 2(1)N</code>.
 (Error return if not.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f</strong>(incfd,*)</td><td><p>array of dependent variable values to be
 interpolated.  F(1+(I-1)*INCFD) is value corresponding to
 X(I).  DPCHIM is designed for monotonic data, but it will
 work for any F-array.  It will force extrema at points where
 monotonicity switches direction.  If some other treatment of
 switch points is desired, <a href="../proc/dpchic.html">dpchic</a> should be used instead.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d</strong>(incfd,*)</td><td><p>array of derivative values at the data
 points.  If the data are monotonic, these values will
 determine a monotone cubic Hermite function.
 The value corresponding to X(I) is stored in
 <code>D(1+(I-1)*INCFD),  I=1(1)N</code>.
 No other entries in D are changed.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>incfd</strong></td><td><p>increment between successive values in F and D.
 This argument is provided primarily for 2-D applications.
 (Error return if  INCFD&lt;1).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ierr</strong></td><td><p>error flag.</p>
<ul>
<li>
<p>Normal return:</p>
<ul>
<li>IERR = 0  (no errors).</li>
</ul>
</li>
<li>
<p>Warning error:</p>
<ul>
<li>IERR&gt;0  means that IERR switches in the direction
  of monotonicity were detected.</li>
</ul>
</li>
<li>
<p>"Recoverable" errors (The D-array has not been changed in any of these cases.):</p>
<ul>
<li>IERR = -1  if N&lt;2 .</li>
<li>IERR = -2  if INCFD&lt;1 .</li>
<li>IERR = -3  if the X-array is not strictly increasing.</li>
</ul>
</li>
</ul>
<p>NOTE: The above errors are checked in the order listed,
 and following arguments have <strong>NOT</strong> been validated.</p></td>
  
</tr>

</tbody>
</table>

      
    
    

  </div>
  </div>

    
    
  <div class="panel panel-default">
  <div class="panel-heading codesum"><span class="anchor" id="proc-dpchsp"></span><h3>
public subroutine <a href='../proc/dpchsp.html'>dpchsp</a>(ic, vc, n, x, f, d, incfd, wk, nwk, ierr)
    
    
   
</h3></div>
  <div class="panel-body">
       
    







<p>Piecewise Cubic Hermite Spline</p><a href="../proc/dpchsp.html" class="pull-right"><emph>Read more&hellip;</emph></a>
    
    <h4>Arguments</h4>
    
      
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ic</strong>(2)</td><td><p>integer array of length 2 specifying desired
 boundary conditions:</p>
<ul>
<li>IC(1) = IBEG, desired condition at beginning of data.</li>
<li>IC(2) = IEND, desired condition at end of data.</li>
</ul>
<p>Valid values for IBEG:</p>
<ul>
<li>IBEG = 0  to set D(1) so that the third derivative is
     continuous at X(2).  This is the "not a knot" condition
     provided by de Boor's cubic spline routine CUBSPL.
     <strong>This is the default boundary condition.</strong></li>
<li>IBEG = 1  if first derivative at X(1) is given in VC(1).</li>
<li>IBEG = 2  if second derivative at X(1) is given in VC(1).</li>
<li>IBEG = 3  to use the 3-point difference formula for D(1).
            (Reverts to the default b.c. if N&lt;3).</li>
<li>IBEG = 4  to use the 4-point difference formula for D(1).
            (Reverts to the default b.c. if N&lt;4).</li>
</ul>
<p>NOTES:</p>
<ol>
<li>An error return is taken if IBEG is out of range.</li>
<li>For the "natural" boundary condition, use IBEG=2 and
    VC(1)=0.</li>
</ol>
<p>IEND may take on the same values as IBEG, but applied to
 derivative at X(N).  In case IEND = 1 or 2, the value is
 given in VC(2).</p>
<p>NOTES:</p>
<ol>
<li>An error return is taken if IEND is out of range.</li>
<li>For the "natural" boundary condition, use IEND=2 and
     VC(2)=0.</li>
</ol></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>vc</strong>(2)</td><td><p>array of length 2 specifying desired boundary
 values, as indicated above.</p>
<ul>
<li>VC(1) need be set only if IC(1) = 1 or 2 .</li>
<li>VC(2) need be set only if IC(2) = 1 or 2 .</li>
</ul></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>n</strong></td><td><p>number of data points.  (Error return if N&lt;2).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>x</strong>(*)</td><td><p>array of independent variable values.  The
 elements of X must be strictly increasing:
 <code>X(I-1) &lt; X(I),  I = 2(1)N</code>.
 (Error return if not.)</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>f</strong>(incfd,*)</td><td><p>array of dependent variable values to be
 interpolated.  F(1+(I-1)*INCFD) is value
 corresponding to X(I).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>d</strong>(incfd,*)</td><td><p>array of derivative values at the data
 points.  These values will determine the cubic spline
 interpolant with the requested boundary conditions.
 The value corresponding to X(I) is stored in
 <code>D(1+(I-1)*INCFD),  I=1(1)N</code>.
 No other entries in D are changed.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>incfd</strong></td><td><p>increment between successive values in F and D.
 This argument is provided primarily for 2-D applications.
 (Error return if  INCFD&lt;1).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>real(kind=wp),</td>
  <td>intent(inout)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>wk</strong>(2,*)</td><td><p>array of working storage.</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>nwk</strong></td><td><p>length of work array. (Error return if NWK&lt;2*N).</p></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" ></span>integer,</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>ierr</strong></td><td><p>error flag.</p>
<ul>
<li>Normal return:<ul>
<li>IERR = 0  (no errors).</li>
</ul>
</li>
<li>
<p>"Recoverable" errors:</p>
<ul>
<li>IERR = -1  if N&lt;2 .</li>
<li>IERR = -2  if INCFD&lt;1 .</li>
<li>IERR = -3  if the X-array is not strictly increasing.</li>
<li>IERR = -4  if IBEG&lt;0 or IBEG&gt;4 .</li>
<li>IERR = -5  if IEND&lt;0 of IEND&gt;4 .</li>
<li>IERR = -6  if both of the above are true.</li>
<li>IERR = -7  if NWK is too small.</li>
</ul>
<p>NOTE:  The above errors are checked in the order listed,
      and following arguments have <strong>NOT</strong> been validated.
(The D-array has not been changed in any of these cases.)</p>
<ul>
<li>IERR = -8  in case of trouble solving the linear system
            for the interior derivative values.
(The D-array may have been changed in this case.)
(             Do <strong>NOT</strong> use it!                )</li>
</ul>
</li>
</ul></td>
  
</tr>

</tbody>
</table>

      
    
    

  </div>
  </div>

    
    </section>    
    <br>
    
    
    
    </div>
  </div>

  
    <hr>    
    </div> <!-- /container -->
    <footer>
      <div class="container">
      <div class="row">
        <div class="col-xs-6 col-md-6"><p>PCHIP was developed by Jacob Williams<br>&copy; 2021 
                                          </p>
        </div>
        <div class="col-xs-6 col-md-6">
          <p class="text-right">
            Documentation generated by 
            <a href="https://github.com/Fortran-FOSS-Programmers/ford">FORD</a>
            
            
          </p>
        </div>
      </div>
      <br>
      </div> <!-- /container -->    
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
<!--
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
-->
    <script src="../js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../js/ie10-viewport-bug-workaround.js"></script>

    <!-- MathJax JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
        jax: ['input/TeX','input/MathML','output/HTML-CSS'],
        extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
      });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    
    <script src="../tipuesearch/tipuesearch_content.js"></script>
    <script src="../tipuesearch/tipuesearch_set.js"></script>
    <script src="../tipuesearch/tipuesearch.js"></script>
    
    
  </body>
</html>